Short Answers:

	1.	O(n) is an example of the running time of an algorithm.  The O means that it’s an upper bound, the algorithm can take up to or equal a given running time.  There’s a separate notation for a lower bound.  The ’n’ represents the number of inputs to the function.  O(n) means that the running time of the algorithm should increase linearly as the input increases.  O(n) doesn’t necessarily mean that the inputs are only processed a single time; constants are dropped when calculating runtime, so O(5n + 50) is equivalent to O(n).  O(n2) means that the running time will increase quadratically as the input increases.  Algorithms that are O(n2) can be algorithms that have double for loops, do comparisons, etc.  Lower terms are dropped as well as constants, so O(n2 + n) is equivalent to O(n2).
	2.	Quick sort is a sorting algorithm that works in place, meaning it doesn’t require any additional space to perform the sort.  The way quick sort works is that a pivot, a random element in the array is chosen.  Then all the remaining elements are split such that the elements less than the pivot are in the first partition and the elements greater than the pivot are in the second.  To create the partitions, elements are swapped until all the values greater and less than the pivot are grouped accordingly.  The quick sort function is called on each of the partitions, sorting the sub-arrays in exactly the same way.  As the algorithm comes up the recursive stack, it just needs to put the sorted first partition, then the pivot, then the second sorted partition (no merging needs to happen because everything is in order at this point).  It has a worst case runtime of O(n2), but an average case runtime of O(n log n).
	3.	A pointer is a reference to the address of a value stored in memory.  They’re used so that pointers (the addresses) can be passed around to various methods without needing to constantly copy and move large amounts of data.  You can also have multiple pointers pointing to the same address in memory, meaning if you edit the value the pointer is pointing to, any other pointers pointing to that same address will see the change next time they try to access the value.  This allows you to have methods that can modify one of their parameters outside the scope of the method.
	4.	Stack memory is the memory for the objects pushed onto a stack data structure for each nested method call.  Stacks are last-in-first-out, so a objects created within method are added to the stack and then automatically popped once the method is finished.  This means the objects created by the root of the stack trace remain for the entire time, whereas leaf methods will have objects added then immediately popped. Once they are popped from the stack memory, those objects have gone out scope and can no longer be accessed by the program.  Heap memory is more general memory that is managed more directly by the program.  The memory is manually allocated/deallocated and objects stay in memory until they are manually deallocated rather than automatically being removed as a function finishes.  They also can be accessed from any function rather than just the one that created it.
	5.	Garbage collection is a way of managing memory.  It makes it so that the developer does not need to worry about manually allocating blocks of memory and then deallocating when the object is no longer needed.  It’s an automatic function of languages that determines which objects are still in use vs which objects that are no longer being referenced and can have their memory deallocated.  It reduces bugs because developers can make mistakes and accidentally deallocate something that still has pointers pointing to it or leave something allocated (wasting memory) long after it is no longer being used.  
